{"version":3,"sources":["../../../lib/compiler/blocks.js"],"names":["t","require","c","handleBinaryExpression","node","left","right","out","side","forEach","block","isCallExpression","isIdentifier","callee","name","push","cleanName","replaceWith","newNode","getBlocks","ast","Array","isArray","map","isReturnStatement","argument","isConditionalExpression","alternate","consequent","isBinaryExpression","filter","Boolean","reduce","prev","arr","concat","everyBlock","keysUsed","props","includes","objectProperty","stringLiteral","functionExpression","identifier","runtimeParams","blockStatement","returnStatement","callExpression","memberExpression","BLOCKS","blocks","body","nodes","length","expressionStatement","assignmentExpression","objectExpression","module","exports"],"mappings":"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","file":"blocks.js","sourcesContent":["'use strict';\n\nconst t = require('babel-types');\n\nconst c = require('./constants');\n\nfunction handleBinaryExpression(node) {\n  const { left, right } = node;\n  const out = [];\n\n  right.side = 'right';\n  left.side = 'left';\n\n  [right, left].forEach((block) => {\n    if (t.isCallExpression(block) && t.isIdentifier(block.callee, { name: 'iter' })) {\n      out.push({\n        block,\n        name: block.name,\n        cleanName: block.cleanName,\n        replaceWith: (newNode) => {\n          node[block.side] = newNode;\n        },\n      });\n    } else {\n      out.push(...getBlocks(block));\n    }\n  });\n\n  return out;\n}\n\n/**\n * Get block from ast array\n * @param {object[]} ast\n * @returns {object}\n */\nfunction getBlocks(ast) {\n  ast = Array.isArray(ast) ? ast : [ast];\n\n  return ast.map((node) => {\n    if (t.isReturnStatement(node)) {\n      return getBlocks(node.argument);\n    }\n    if (t.isConditionalExpression(node)) {\n      return node.alternate ? [\n        ...getBlocks(node.consequent),\n        ...getBlocks(node.alternate),\n      ] : getBlocks(node.consequent);\n    }\n    if (t.isBinaryExpression(node)) {\n      return handleBinaryExpression(node);\n    }\n\n    return null;\n  }).filter(Boolean).reduce((prev, arr) => prev.concat(arr), []);\n}\n\nfunction everyBlock({ keysUsed, props }, { name, cleanName, block, replaceWith }) {\n  if (keysUsed.includes(name)) {\n    return { keysUsed, props };\n  }\n  keysUsed.push(name);\n\n  props.push(t.objectProperty(\n    t.stringLiteral(name),\n    t.functionExpression(\n      t.identifier(cleanName),\n      c.runtimeParams,\n      t.blockStatement([t.returnStatement(block)])\n    )\n  ));\n\n  replaceWith(t.callExpression(t.memberExpression(\n    c.BLOCKS,\n    t.stringLiteral(name),\n    true\n  ), c.runtimeParams));\n\n  return { keysUsed, props };\n}\n\n/**\n * Pull top-level blocks out of ast and expose them at `compiled.blocks`\n * @param {object} ast\n * @returns {object}\n */\nfunction blocks(ast) {\n  const body = [ast];\n  // start with body of function\n  const nodes = getBlocks(ast.body.body);\n  if (nodes.length) {\n    const { props } = nodes.reduce(everyBlock, { keysUsed: [], props: [] });\n    body.push(t.expressionStatement(t.assignmentExpression(\n      '=',\n      c.BLOCKS,\n      t.objectExpression(props)\n    )));\n  }\n\n  return body;\n}\n\nmodule.exports = blocks;\n"]}