{"version":3,"sources":["../../../lib/compiler/tokens.js"],"names":["_","require","first","arr","fn","l","length","i","res","exports","matchPattern","tokens","input","end","Tok","matches","patterns","pattern","match","splitArgs","str","out","inString","currentArg","index","c","push","trim","Token","constructor","tokenType","name","priority","Text","value","Expression","found","extensions","TypeError","Extension","flatMap","Ext","map","join","unescapeMap","StringLiteral","raw","rawValue","replace","Object","assign","SimpleExpression","path","simpleOrString","HelperExpression","helperName","args","arg","OpenIf","not","test","OpenIter","subject","cleanName","Else","Close","RawMustache","expression","EscapedMustache"],"mappings":"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","file":"tokens.js","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\n\n/**\n * Get the first truthy value returned by a mapper function\n * @param {any[]} arr\n * @param {function} fn\n */\nfunction first(arr, fn) {\n  const l = arr.length;\n  for (let i = 0; i < l; i += 1) {\n    const res = fn(arr[i], i);\n    if (res) {\n      return res;\n    }\n  }\n\n  return null;\n}\nexports.first = first;\n\nfunction matchPattern(tokens, input, end) {\n  return first(tokens, (Tok) => {\n    let matches;\n    if (Tok.patterns) {\n      matches = first(Tok.patterns, pattern => input.match(`^(?:${pattern})${end ? '$' : ''}`));\n    } else {\n      matches = input.match(`^(?:${Tok.pattern})${end ? '$' : ''}`);\n    }\n    return matches && [Tok, matches];\n  });\n}\nexports.matchPattern = matchPattern;\n\n/**\n * Split on commas, but ignore commas inside strings\n * @param {string} str\n */\nfunction splitArgs(str) {\n  const out = [];\n\n  let inString = false;\n  let currentArg = '';\n\n  for (let index = 0; index < str.length; index += 1) {\n    const c = str[index];\n    if (c === ',' && !inString) {\n      out.push(currentArg.trim());\n      currentArg = '';\n    } else if (currentArg.length === 0 && c === '\"' && !inString) {\n      currentArg += c;\n      inString = true;\n    } else if (inString && c === '\"' && str[index - 1] !== '\\\\') {\n      currentArg += c;\n      inString = false;\n    } else if (!(c === ' ' && currentArg.length === 0)) {\n      currentArg += c;\n    }\n  }\n  out.push(currentArg.trim());\n\n  return out;\n}\nexports.splitArgs = splitArgs;\n\nclass Token {\n  constructor() {\n    this.tokenType = this.constructor.name;\n  }\n\n  static priority = 0;\n}\n\nclass Text extends Token {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n}\n\nclass Expression extends Token {\n  constructor(value) {\n    super();\n\n    const found = matchPattern(Expression.extensions, value, true);\n\n    if (!found) {\n      throw TypeError('Invalid arguments');\n    }\n\n    const [Extension, matches] = found;\n    return new Extension(...matches);\n  }\n\n  static extensions = [];\n\n  static get pattern() {\n    return _.flatMap(Expression.extensions, Ext => Ext.patterns || Ext.pattern)\n      .map(pattern => `(?:${pattern})`)\n      .join('|');\n  }\n}\n\nconst unescapeMap = {\n  '\\\\b': '\\b',\n  '\\\\t': '\\t',\n  '\\\\n': '\\n',\n  '\\\\v': '\\v',\n  '\\\\f': '\\f',\n  '\\\\r': '\\r',\n  '\\\\\"': '\"',\n  '\\\\\\'': '\\'',\n  '\\\\\\\\': '\\\\',\n};\n\nclass StringLiteral extends Token {\n  constructor(raw, rawValue) {\n    super();\n\n    const value = rawValue.replace(/\\\\(.)/g, (str, c) => unescapeMap[str] || c);\n    Object.assign(this, { raw, rawValue, value });\n  }\n\n  static pattern = '\"((?:\\\\\\\\.|[^\"\\\\n])*)\"';\n}\n\nExpression.extensions.push(StringLiteral);\n\nclass SimpleExpression extends Token {\n  constructor(path) {\n    super();\n    Object.assign(this, { path });\n  }\n\n  static pattern = '[@a-zA-Z0-9/._:\\\\-]+';\n}\n\nExpression.extensions.push(SimpleExpression);\n\nconst simpleOrString = `(?:${StringLiteral.pattern}|${SimpleExpression.pattern})`;\n\nclass HelperExpression extends Token {\n  constructor(raw, helperName, args) {\n    super();\n    if (args) {\n      const arr = splitArgs(args.replace(/^ *, */, '')).map(arg => new Expression(arg));\n      Object.assign(this, { raw, helperName, args: arr });\n    } else {\n      Object.assign(this, { raw, helperName, args: [] });\n    }\n  }\n\n  static patterns = [\n    `function\\\\.(${SimpleExpression.pattern})((?: *, *${simpleOrString})*)`,\n    `(${SimpleExpression.pattern})(?:\\\\( *(${simpleOrString}(?: *, *${simpleOrString})*)? *\\\\))`,\n  ];\n}\n\nExpression.extensions.push(HelperExpression);\n\nclass OpenIf extends Token {\n  constructor(raw, not, test) {\n    super();\n    Object.assign(this, { raw, not: !!not, test: new Expression(test) });\n  }\n\n  static patterns = [\n    `<!-- IF (!?)(${Expression.pattern}) -->`,\n    `{{{ ?if (!?)(${Expression.pattern}) ?}}}`,\n  ];\n\n  static priority = 60;\n}\n\nclass OpenIter extends Token {\n  constructor(raw, subject) {\n    super();\n    Object.assign(this, {\n      raw,\n      subject: new SimpleExpression(subject),\n      name: subject.replace(/^[./]*/, ''),\n      cleanName: subject.replace(/^[./]*/, '').replace(/(^[^a-zA-Z_])|[^a-zA-Z0-9_]/g, '_'),\n    });\n  }\n\n  static patterns = [\n    `<!-- BEGIN (${SimpleExpression.pattern}) -->`,\n    `{{{ ?each (${SimpleExpression.pattern}) ?}}}`,\n  ];\n\n  static priority = 50;\n}\n\nclass Else extends Token {\n  static patterns = [\n    '<!-- ELSE -->',\n    '{{{ ?else ?}}}',\n  ];\n\n  static priority = 40;\n}\n\nclass Close extends Token {\n  constructor(raw) {\n    super();\n    Object.assign(this, { raw });\n  }\n\n  static patterns = [\n    '<!-- END(.*?) -->',\n    '{{{ ?end ?}}}',\n  ];\n\n  static priority = 30;\n}\n\nclass RawMustache extends Token {\n  constructor(raw, expression) {\n    super();\n    Object.assign(this, { raw, expression: new Expression(expression) });\n  }\n\n  static pattern = `\\\\{\\\\{(${Expression.pattern})\\\\}\\\\}`;\n\n  static priority = 20;\n}\n\nclass EscapedMustache extends RawMustache {\n  static pattern = `\\\\{(${Expression.pattern})\\\\}`;\n\n  static priority = 10;\n}\n\nconst tokens = {\n  Token,\n  Text,\n  StringLiteral,\n  Expression,\n  SimpleExpression,\n  HelperExpression,\n  OpenIf,\n  OpenIter,\n  Else,\n  Close,\n  RawMustache,\n  EscapedMustache,\n};\n\nexports.tokens = tokens;\n"]}