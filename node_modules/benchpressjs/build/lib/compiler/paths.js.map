{"version":3,"sources":["../../../lib/compiler/paths.js"],"names":["relative","basePath","relPath","backPattern","rel","replace","path","test","resolve","base","split","found","relStart","baseLen","l","length","j","i","slice","concat","join","exports"],"mappings":"AAAA;;AAEA,SAASA,QAAT,CAAkBC,QAAlB,EAA4BC,OAA5B,EAAqC;AACnC,QAAMC,cAAc,aAApB;AACA,QAAMC,MAAMF,QAAQG,OAAR,CAAgB,SAAhB,EAA2B,EAA3B,CAAZ;AACA,MAAIC,IAAJ;AACA,MAAI,CAACL,QAAL,EAAe;AACbK,WAAQ,GAAEF,IAAIC,OAAJ,CAAY,KAAZ,EAAmB,EAAnB,CAAuB,EAAjC;AACD,GAFD,MAEO;AACLC,WAAQ,GAAEL,QAAS,IAAGG,IAAIC,OAAJ,CAAY,KAAZ,EAAmB,EAAnB,CAAuB,EAA7C;AACD;AACD,SAAOF,YAAYI,IAAZ,CAAiBD,IAAjB,CAAP,EAA+B;AAC7BA,WAAOA,KAAKD,OAAL,CAAaF,WAAb,EAA0B,EAA1B,CAAP;AACD;;AAED,SAAOG,IAAP;AACD;;AAED;;;;;AAKA,SAASE,OAAT,CAAiBP,QAAjB,EAA2BC,OAA3B,EAAoC;AAClC;AACA,MAAI,WAAWK,IAAX,CAAgBL,OAAhB,CAAJ,EAA8B;AAC5B,WAAOF,SAASC,QAAT,EAAmBC,OAAnB,CAAP;AACD;;AAED;AACA;AACA;AACA;AACA,QAAMO,OAAOR,SAASS,KAAT,CAAe,GAAf,CAAb;AACA,QAAMN,MAAMF,QAAQQ,KAAR,CAAc,GAAd,CAAZ;AACA;AACA;AACA,MAAIC,QAAQ,KAAZ;AACA,MAAIC,QAAJ;AACA,MAAIC,OAAJ;;AAEA,OAAK,IAAIC,IAAIV,IAAIW,MAAjB,EAAyBD,IAAI,CAAJ,IAAS,CAACH,KAAnC,EAA0CG,KAAK,CAA/C,EAAkD;AAChD;AACA,SAAK,IAAIE,IAAIP,KAAKM,MAAL,GAAcD,CAA3B,EAA8BE,KAAK,CAAL,IAAU,CAACL,KAAzC,EAAgDK,KAAK,CAArD,EAAwD;AACtD;AACA;AACA,WAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIH,CAApB,EAAuBG,KAAK,CAA5B,EAA+B;AAC7B,YAAIR,KAAKO,IAAIC,CAAT,EAAYZ,OAAZ,CAAoB,SAApB,EAA+B,EAA/B,MAAuCD,IAAIa,CAAJ,CAA3C,EAAmD;AACjDN,kBAAQ,IAAR;AACA,cAAIM,MAAMH,IAAI,CAAd,EAAiB;AACfF,uBAAWE,CAAX;AACAD,sBAAUG,IAAIF,CAAd;AACD;AACF,SAND,MAMO;AACLH,kBAAQ,KAAR;AACA;AACD;AACF;AACF;AACF;;AAED,MAAIA,KAAJ,EAAW;AACT,WAAOF,KAAKS,KAAL,CAAW,CAAX,EAAcL,OAAd,EAAuBM,MAAvB,CAA8Bf,IAAIc,KAAJ,CAAUN,QAAV,CAA9B,EAAmDQ,IAAnD,CAAwD,GAAxD,CAAP;AACD;;AAED;AACA,SAAOlB,OAAP;AACD;;AAEDmB,QAAQb,OAAR,GAAkBA,OAAlB","file":"paths.js","sourcesContent":["'use strict';\n\nfunction relative(basePath, relPath) {\n  const backPattern = /[^.]*\\.\\.\\//;\n  const rel = relPath.replace(/^\\.\\.\\//, '');\n  let path;\n  if (!basePath) {\n    path = `${rel.replace(/^\\./, '')}`;\n  } else {\n    path = `${basePath}.${rel.replace(/^\\./, '')}`;\n  }\n  while (backPattern.test(path)) {\n    path = path.replace(backPattern, '');\n  }\n\n  return path;\n}\n\n/**\n * Resolve a full path from a base path and relative path\n * @param {string} basePath\n * @param {string} relPath\n */\nfunction resolve(basePath, relPath) {\n  // already relative, so easy work\n  if (/^\\.\\.?\\//.test(relPath)) {\n    return relative(basePath, relPath);\n  }\n\n  // otherwise we have to figure out if this is something like\n  // BEGIN a.b.c\n  // `- {a.b.c.d}\n  // or if it's an absolute path\n  const base = basePath.split('.');\n  const rel = relPath.split('.');\n  // find largest possible match in the base path\n  // decrease size of slice until a match is found\n  let found = false;\n  let relStart;\n  let baseLen;\n\n  for (let l = rel.length; l > 0 && !found; l -= 1) {\n    // slide through array from end to start until a match is found\n    for (let j = base.length - l; j >= 0 && !found; j -= 1) {\n      // check every element from (j) to (j + l) for equality\n      // if not equal, break right away\n      for (let i = 0; i < l; i += 1) {\n        if (base[j + i].replace(/\\[\\d+]$/, '') === rel[i]) {\n          found = true;\n          if (i === l - 1) {\n            relStart = l;\n            baseLen = j + l;\n          }\n        } else {\n          found = false;\n          break;\n        }\n      }\n    }\n  }\n\n  if (found) {\n    return base.slice(0, baseLen).concat(rel.slice(relStart)).join('.');\n  }\n\n  // assume its an absolute path\n  return relPath;\n}\n\nexports.resolve = resolve;\n"]}