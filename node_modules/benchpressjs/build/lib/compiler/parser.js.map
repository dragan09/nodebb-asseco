{"version":3,"sources":["../../../lib/compiler/parser.js"],"names":["Close","require","tokens","paths","expressionPaths","basePath","expression","expr","Object","assign","tokenType","path","resolve","args","map","arg","subroutines","OpenIf","token","rest","iterSuffix","blockBody","tokensHandled","parse","test","body","OpenIter","subject","Else","RawMustache","EscapedMustache","Text","len","length","i","slice","branches","shouldBreak","push","parser","toks","reduce","prev","tok","module","exports"],"mappings":"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","file":"parser.js","sourcesContent":["'use strict';\n\nconst { Close } = require('./tokens').tokens;\nconst paths = require('./paths');\n\n/**\n * Resolve all expression paths relative to the loop\n * @param {string} basePath\n * @param {object} expression\n */\nfunction expressionPaths(basePath, expression) {\n  const expr = Object.assign({}, expression);\n  if (expr.tokenType === 'SimpleExpression') {\n    if (expr.path === '@value') {\n      expr.path = basePath;\n    } else {\n      expr.path = paths.resolve(basePath, expr.path);\n    }\n  } else if (expr.tokenType === 'HelperExpression') {\n    expr.args = expr.args.map((arg) => {\n      if (arg.tokenType === 'StringLiteral') {\n        return arg;\n      }\n\n      return expressionPaths(basePath, arg);\n    });\n  }\n\n  return expr;\n}\n\nconst subroutines = {\n  OpenIf(token, rest, basePath, iterSuffix) {\n    const [blockBody, tokensHandled] = parse(rest, basePath, iterSuffix);\n\n    const test = expressionPaths(basePath, token.test);\n    return [[Object.assign({}, token, { test, body: blockBody })], tokensHandled];\n  },\n  OpenIter(token, rest, basePath, iterSuffix) {\n    const path = paths.resolve(basePath, token.subject.path);\n    const [blockBody, tokensHandled] = parse(rest, `${path}[${iterSuffix}]`, iterSuffix + 1);\n\n    const subject = Object.assign({}, token.subject, { path });\n    return [\n      [Object.assign({}, token, {\n        body: blockBody,\n        subject,\n        iterSuffix,\n      })],\n      tokensHandled,\n    ];\n  },\n  Else(token, rest, basePath, iterSuffix) {\n    const [blockBody, tokensHandled] = parse(rest, basePath, iterSuffix);\n    return [[Object.assign({}, token, { body: blockBody })], tokensHandled];\n  },\n  RawMustache(token, rest, basePath) {\n    const expression = expressionPaths(basePath, token.expression);\n    return [[Object.assign({}, token, { expression })], 1];\n  },\n  EscapedMustache(...args) {\n    return subroutines.RawMustache(...args);\n  },\n  Text(token) {\n    return [[token], 1];\n  },\n  Close() {\n    return [[], 1, true];\n  },\n};\n\n/**\n * Parse an array of tokens into a syntax tree\n * @param {object[]} tokens\n * @param {string} basePath\n * @param {number} iterSuffix\n * @returns {[object[], number]}\n */\nfunction parse(tokens, basePath, iterSuffix) {\n  const len = tokens.length;\n  const body = [];\n\n  let i = 0;\n  while (i < len) {\n    const token = tokens[i];\n    if (subroutines[token.tokenType]) {\n      const rest = tokens.slice(i + 1);\n      const [\n        branches,\n        tokensHandled,\n        shouldBreak,\n      ] = subroutines[token.tokenType](token, rest, basePath, iterSuffix);\n\n      body.push(...branches);\n\n      i += tokensHandled;\n\n      if (shouldBreak) {\n        break;\n      }\n    } else {\n      i += 1;\n    }\n  }\n\n  return [body, i + 1];\n}\n\n/**\n * Parse an array of tokens into a syntax tree\n * @param {object[]} tokens\n * @returns {object}\n */\nfunction parser(tokens) {\n  // add Close token before each Else\n  const toks = tokens.reduce((prev, tok) => {\n    if (tok.tokenType === 'Else') {\n      return [...prev, new Close(), tok];\n    }\n\n    return [...prev, tok];\n  }, []);\n\n  const [body] = parse(toks, '', 1);\n  return body;\n}\n\nparser.subroutines = subroutines;\n\nmodule.exports = parser;\n"]}